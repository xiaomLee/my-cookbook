<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>array</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../README.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 计算机网络</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../network/tcp&ip.html"><strong aria-hidden="true">2.1.</strong> tcp/ip</a></li><li class="chapter-item expanded "><a href="../network/http&https&tls.html"><strong aria-hidden="true">2.2.</strong> http/https</a></li><li class="chapter-item expanded "><a href="../network/http2.html"><strong aria-hidden="true">2.3.</strong> http2</a></li><li class="chapter-item expanded "><a href="../network/grpc.html"><strong aria-hidden="true">2.4.</strong> grpc</a></li><li class="chapter-item expanded "><a href="../network/udp.html"><strong aria-hidden="true">2.5.</strong> udp</a></li><li class="chapter-item expanded "><a href="../network/dns.html"><strong aria-hidden="true">2.6.</strong> dns</a></li><li class="chapter-item expanded "><a href="../network/quic.html"><strong aria-hidden="true">2.7.</strong> quic</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Linux</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../linux/README.html"><strong aria-hidden="true">3.1.</strong> linux</a></li><li class="chapter-item expanded "><a href="../linux/ids.html"><strong aria-hidden="true">3.2.</strong> 机器标识码/硬件ID</a></li><li class="chapter-item expanded "><a href="../linux/process-thread-coroutine.html"><strong aria-hidden="true">3.3.</strong> 进程/线程/协程</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 数据结构与算法</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../algorithm/list.html"><strong aria-hidden="true">4.1.</strong> List</a></li><li class="chapter-item expanded "><a href="../algorithm/stack.html"><strong aria-hidden="true">4.2.</strong> stack</a></li><li class="chapter-item expanded "><a href="../algorithm/tree.html"><strong aria-hidden="true">4.3.</strong> tree</a></li><li class="chapter-item expanded "><a href="../algorithm/array.html" class="active"><strong aria-hidden="true">4.4.</strong> array</a></li><li class="chapter-item expanded "><a href="../algorithm/backtrack.html"><strong aria-hidden="true">4.5.</strong> 回溯算法</a></li><li class="chapter-item expanded "><a href="../algorithm/dp.html"><strong aria-hidden="true">4.6.</strong> 动态规划</a></li><li class="chapter-item expanded "><a href="../algorithm/bloom.html"><strong aria-hidden="true">4.7.</strong> 布隆过滤器</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 语言</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language/golang.html"><strong aria-hidden="true">5.1.</strong> go</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 常用组件</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../components/mysql.html"><strong aria-hidden="true">6.1.</strong> mysql</a></li><li class="chapter-item expanded "><a href="../components/redis.html"><strong aria-hidden="true">6.2.</strong> redis</a></li><li class="chapter-item expanded "><a href="../components/kafka.html"><strong aria-hidden="true">6.3.</strong> kafka</a></li><li class="chapter-item expanded "><a href="../components/rabbitmq.html"><strong aria-hidden="true">6.4.</strong> rabbitmq</a></li><li class="chapter-item expanded "><a href="../components/mqtt.html"><strong aria-hidden="true">6.5.</strong> mqtt</a></li><li class="chapter-item expanded "><a href="../components/nginx.html"><strong aria-hidden="true">6.6.</strong> nginx</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 分布式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../distributed/raft.html"><strong aria-hidden="true">7.1.</strong> raft</a></li><li class="chapter-item expanded "><a href="../distributed/etcd.html"><strong aria-hidden="true">7.2.</strong> etcd</a></li><li class="chapter-item expanded "><a href="../distributed/zk.html"><strong aria-hidden="true">7.3.</strong> zookeeper</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> AI</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ai/video.html"><strong aria-hidden="true">8.1.</strong> video</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> AIOT</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> 容器技术</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../devops/docker.html"><strong aria-hidden="true">10.1.</strong> docker</a></li><li class="chapter-item expanded "><a href="../devops/k8s/README.html"><strong aria-hidden="true">10.2.</strong> kubernetes</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> 项目实践</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../projects/business-gw.html"><strong aria-hidden="true">11.1.</strong> 通用业务网关</a></li><li class="chapter-item expanded "><a href="../projects/trade-engin.html"><strong aria-hidden="true">11.2.</strong> 交易所</a></li></ol></li><li class="chapter-item expanded "><a href="../bak/bak.html"><strong aria-hidden="true">12.</strong> 归档</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/xiaomLee/my-cookbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/xiaomLee/my-cookbook/edit/master/.//algorithm/array.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<h2 id="常用技巧"><a class="header" href="#常用技巧">常用技巧</a></h2>
<ul>
<li>排序</li>
<li>双指针</li>
<li>滑动窗口</li>
<li>二分搜索</li>
<li>前缀和</li>
<li>差分数组</li>
<li>花式遍历</li>
</ul>
<h2 id="常见题型"><a class="header" href="#常见题型">常见题型</a></h2>
<h3 id="排序"><a class="header" href="#排序">排序</a></h3>
<p><strong>快速排序</strong></p>
<p>快排算法框架类似二叉树的前序遍历, partition函数选出数组的分割位置pos, 在该位置前都比nums[pos]小, 之后都大于等nums[pos]。</p>
<p>quickSort(nums []int, start, end int) {
if start&gt;=end {
return
}
pos := partition(nums, start, end)
quickSort(nums, start, pos-1)
quickSort(nums, pos+1, end)
}</p>
<pre><code class="language-go">func QuickSort(nums []int) {
    sort(nums, 0, len(nums)-1)
}

func sort(nums []int, start, end int){
    if start &gt;= end {
        return
    }
    pos := partition(nums, start, end)
    sort(nums, start, pos-1)
    sort(nums, pos+1, end)
}

func partition(nums, start, end int) {
    // 选取基准值pivot, 此处以nums[end]为基准值进行比较
    pos := end
    pivot := nums[pos]
    // 双指针i, j 初始化为start; j开始遍历, 当nums[j]&lt; pivot时, 交换i，j &amp;&amp; i++
    // 遍历结束，交换i， pos； 返回i
    i, j := start, start
    for j&lt;pos {
        if nums[j] &lt; pivot {
            nums[i], nums[j] = nums[j], nums[i]
            i++
        }
        j++
    }
    // 遍历结束，交换i， pos； 返回i
    nums[i], nums[pos] = nums[pos], nums[i]
    return i
}
</code></pre>
<p>技巧，有时数组会部分有序或整体倒序，导致算法复杂度很高，此时可以先进行shuffle洗牌操作，重新打乱数组顺序。</p>
<p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95.md">参考</a></p>
<pre><code class="language-go">// Knuth 洗牌算法
// golang 自带有 rand.Shuffle(n, func(i, j))
func shuffle(nums []int) {
    n := len(nums)
    for i:=0; i&lt;n; i++ {
        j := rand.Intn(n-i) + i
        nums[i], num[j] = nums[j], nums[i]
    }
}
</code></pre>
<p><strong>归并排序</strong></p>
<p>类似二叉树的后续遍历</p>
<pre><code class="language-go">func mergeSort(nums []int) []int {
    if len(nums) &lt;= 1 {
        return
    }
    mid := len(nums)/2
    left := mergeSort(nums[:mid])
    right := mergeSort(nums[mid:])
    return merge(left, right)
}
func merge(nums1, nums2 []int) []int {
    res := make([]int, 0)
    i, j := 0, 0
    for i&lt;len(nums1) &amp;&amp; j&lt;len(nums2) {
        if nums1[i] &lt; nums2[j] {
            res = append(res, nums1[i])
            i++
        }else {
            res = append(res, nums2[j])
            j++
        }
    }
    if i&lt;len(nums1) {
        res = append(res, nums1[i:]...)
    }
    if j&lt;len(nums2) {
        res = append(res, nums2[j:]...)
    }
    return res
}
</code></pre>
<p><strong>堆排序</strong></p>
<p>排序步骤：</p>
<ol>
<li>将数组构建成大顶堆(小顶堆)——用数组表示的完全二叉树结构——nums[0]是根节点，堆中最大(最小)</li>
<li>堆顶出队，与数组最后一位交换(将最大值放于数组最后) swap(nums, 0, len(nums)-1)</li>
<li>剩余元素nums[:len(nums)-2]继续构建堆结构——将nums[0]下沉到合适的位置 sink(nums, end)</li>
<li>循环2，至所有数据排序</li>
</ol>
<p>构建堆：</p>
<ol>
<li>首先构建大顶堆, nums[0] 为树的根节点，构建完全二叉树，则存在如下下标关系 left = 2<em>i+1 right = 2</em>i+2</li>
<li>从最后一个非叶子节点开始进行上浮操作，最后一个非叶子节点为 len(nums)/2-1</li>
<li>swim(nums, i) 以nums[i]为根， 分别与left right进行比较 nums[2<em>i+1] nums[2</em>i+2]</li>
<li>循环至i==0</li>
</ol>
<pre><code class="language-go">func heapSort(nums []int) {
    //构建大顶堆
    for i:=len(nums)/2-1; i&gt;=0; i-- {
        swim(nums, i)
    }
    // 交换 排序
    for i:=len(nums)-1; i&gt;=0; i-- {
        // swap 0, i
        nums[0], nums[i] = nums[i], nums[0]
        // sink
        sink(nums, i)
    }
    return nums
}

func swim(nums []int, root int) {
    for {
        l := 2*root + 1
        r := 2*root +2
        idx := root
        if l&lt;len(nums) &amp;&amp; nums[l] &gt; nums[idx] {
            idx = l
        }
        if r&lt;len(nums) &amp;&amp; nums[r] &gt; nums[idx] {
            idx = r
        }
        // 不需要上浮
        if idx == root {
            break
        }
        // 交换
        nums[root], nums[idx] = nums[idx], nums[root]
        root = idx
    }
}

func sink(nums []int, end int) {
    root := 0
    for {
        l := 2*root + 1
        r := 2*root +2
        idx := root
        if l&lt;end &amp;&amp; nums[l] &gt; nums[idx] {
            idx = l
        }
        if r&lt;end &amp;&amp; nums[r] &gt; nums[idx] {
            idx = r
        }
        // 不需要下沉
        if idx == root {
            break
        }
        // 交换
        nums[root], nums[idx] = nums[idx], nums[root]
        root = idx
    }
}
</code></pre>
<h3 id="双指针"><a class="header" href="#双指针">双指针</a></h3>
<p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a></p>
<pre><code class="language-go">// 对有重复数字的 采用hash表
func twoSum(numbers []int, target int) []int {
    // 双指针 
    i, j := 0, len(numbers)-1
    for i&lt;j {
        sum := numbers[i] + numbers[j]
        if sum == target {
            return []int{i+1, j+1}
        }else if sum &lt; target {
            i++
        }else {
            j--
        }
    }
    return nil
}
</code></pre>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></p>
<pre><code class="language-go">func removeDuplicates(nums []int) int {
    // 双指针
    // i, j num[i]!=nums[j]时 将j移到i+1的位置， i++
    i, j := 0, 0
    for j&lt;len(nums) {
        if nums[i]!=nums[j] {
            nums[i+1], nums[j] = nums[j], nums[i+1]
            i++
        }
        j++
    }
    // 返回长度 下标+1
    return i+1
}
</code></pre>
<p><a href="https://leetcode.cn/problems/remove-element/">移除元素</a></p>
<pre><code class="language-go">// 同上
</code></pre>
<p><a href="https://leetcode.cn/problems/move-zeroes/">移动零</a></p>
<pre><code class="language-go">// 同上
</code></pre>
<p><a href="https://leetcode.cn/problems/reverse-string/">反转字符串</a></p>
<p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a></p>
<pre><code class="language-go">// 中心扩散法
func longestPalindrome(s string) string {
    // 以i, i+1为中心向两边扩散
    n := len(s)
    ans := ""
    for i:=0; i&lt;n; i++ {
        res1 := findPalindrome(s, i, i)
        res2 := findPalindrome(s, i, i+1)
        if len(res1) &gt; len(ans) {
            ans = res1
        }
        if len(res2) &gt; len(ans) {
            ans = res2
        }
    }
    return ans
}

// 以i, j为中心的最长回文串
func findPalindrome(s string, i, j int) string {
    for i&gt;=0 &amp;&amp; j&lt;len(s) {
        if s[i] != s[j] {
            break
        }
        i--
        j++
    }
    return s[i+1:j]
}
</code></pre>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></p>
<p><a href="https://leetcode.cn/problems/container-with-most-water/description/">盛最多水的容器</a></p>
<p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">接雨水</a></p>
<pre><code class="language-go">// 算法思路
// 将数组看做一个木桶 arr[0] arr[len(arr)-1]看做木桶的两个边，不断收缩
// 木桶原理：水量以短边为准
func trap(height []int) int {
    left, right := 0, len(height)-1
    maxLeft, maxRight := height[0], height[right]
    res := 0
    for left &lt; right {
        if height[left]&gt;maxLeft {
            maxLeft = height[left]
        }
        if height[right]&gt;maxRight {
            maxRight = height[right]
        }
        if maxLeft&lt;maxRight {
            res += maxLeft-height[left]
            left++
        }else {
            res += maxRight-height[right]
            right--
        }
    }
    return res
}
</code></pre>
<h3 id="滑动窗口"><a class="header" href="#滑动窗口">滑动窗口</a></h3>
<p>解题模板</p>
<pre><code class="language-go">func slideWindow(s string) int {
    // 1. 初始化窗口 left, right := 0, 0 win := make(map[byte]int) 窗口内所有值始终只出现一次
    // 2. 更新窗口 右指针后移 
    // 3. 判断窗口 左指针收缩
    // 4. 统计结果
    left, right := 0, 0
    win := make(map[byte]int)

    for right &lt; len(s) {
        // 更新窗口 右指针后移
        c := s[right]
        win[c] += 1
        right++

        // 收缩左指针 更新窗口
        for win[c] &gt; 1 {
            win[s[left]]--
            left++
        }
        // t统计结果
    }

}
</code></pre>
<p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3.无重复字符的最长子串</a></p>
<pre><code class="language-go">func lengthOfLongestSubstring(s string) int {
    // 滑动窗口 + map
    // 1. 初始化窗口 left, right := 0, 0 win := make(map[byte]int) 窗口内所有值始终只出现一次
    // 2. 更新窗口 右指针后移 
    // 3. 判断窗口 左指针收缩
    // 4. 统计结果
    left, right := 0, 0
    win := make(map[byte]int)
    res := 0

    for right &lt; len(s) {
        // 更新窗口 右指针后移
        c := s[right]
        win[c] += 1
        right++

        // 收缩左指针 更新窗口
        for win[c] &gt; 1 {
            win[s[left]]--
            left++
        }
        // 统计结果
        if right - left &gt; res {
            res = right-left
        }
    }
    return res 
}
</code></pre>
<p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438.找到字符串中所有字母异位词</a></p>
<pre><code class="language-go">func findAnagrams(s string, p string) []int {
    // 滑动窗口
    left, right := 0, 0
    win := make(map[byte]int)
    res := make([]int, 0)

    match := make(map[byte]int)
    for i:=0; i&lt;len(p); i++ {
        match[p[i]] +=1
    }

    for right &lt; len(s) {
        // 更新窗口 指针后移
        win[s[right]] += 1
        right++

        // 收缩窗口
        for right-left&gt;len(p) {
            win[s[left]]--
            left++
        }
        // fmt.Printf("right:%d left:%d win:%v substr:%s \n", right, left, win, s[left:right])

        if right-left == len(p) &amp;&amp; valid(win, match) {
            res = append(res, left)
        }
    }
    return res
}

func valid(win map[byte]int, match map[byte]int) bool {
    for key, val := range match {
        if num, ok := win[key]; !ok || num != val {
            return false
        }
    }
    return true
}
</code></pre>
<p><a href="https://leetcode.cn/problems/permutation-in-string/">567.字符串的排列</a></p>
<pre><code class="language-go">// 同上

func checkInclusion(s1 string, s2 string) bool {
	s1Map := make(map[byte]int)
	for i:=0; i&lt;len(s1); i++ {
		s1Map[s1[i]] += 1
	}

	match := func(m1, m2 map[byte]int) bool {
		for c, val := range m2 {
			if num, ok := m1[c]; !ok || num != val {
				return false
			}
		}
		return true
	}

	win := make(map[byte]int)
	left, right := 0, 0

	for right &lt; len(s2) {
		win[s2[right]] += 1
		right++

		for right - left &gt; len(s1) {
			win[s2[left]]--
			left++
		}

		// fmt.Println(win)

		if right - left == len(s1) &amp;&amp; match(win, s1Map) {
			return true
		}
	}
	return false
}

</code></pre>
<p><a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串</a></p>
<p><a href="https://leetcode.cn/problems/repeated-dna-sequences/">重复的DNA序列</a></p>
<p><a href="https://leetcode.cn/problems/implement-strstr/">实现 strStr()</a></p>
<h3 id="二分查找"><a class="header" href="#二分查找">二分查找</a></h3>
<p>给一个<strong>有序数组</strong>和目标值，找第一次/最后一次/任何一次出现的索引，如果没有出现返回-1</p>
<p>模板四点要素</p>
<ul>
<li>1、初始化：start=0、end=len-1</li>
<li>2、循环退出条件：start + 1 &lt; end</li>
<li>3、比较中点和目标值：A[mid] ==、 &lt;、&gt; target</li>
<li>4、判断最后两个元素是否符合：A[start]、A[end] ? target</li>
</ul>
<pre><code class="language-go">// 二分搜索最常用模板
func search(nums []int, target int) int {
    // 1、初始化start、end
    start := 0
    end := len(nums) - 1
    // 2、处理for循环
    for start+1 &lt; end {
        mid := start + (end-start)/2
        // 3、比较a[mid]和target值
        if nums[mid] == target {
            end = mid
        } else if nums[mid] &lt; target {
            start = mid
        } else if nums[mid] &gt; target {
            end = mid
        }
    }
    // 4、最后剩下两个元素，手动判断
    if nums[start] == target {
        return start
    }
    if nums[end] == target {
        return end
    }
    return -1
}
</code></pre>
<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34.在排序数组中查找元素的第一个和最后一个位置</a></p>
<pre><code class="language-go">func searchRange(nums []int, target int) []int {
    // 二分查找
    // 1. 左边界：right不断左移收缩
    // 2. 右边界：left不断右移收缩
    if len(nums) == 0 {
        return []int{-1, -1}
    }

    res := []int{-1, -1}
    
    // 寻找左边界
    left, right := 0, len(nums)-1
    for left+1&lt;right {
        mid := left + (right-left)/2
        if nums[mid] &gt;= target {
            right = mid
        }else {
            left = mid
        }
    }
    // 判断最后两个元素nums[left] nums[right]
    if nums[right] == target {
        res[0] = right
    }
    if nums[left] == target {
        res[0] = left
    }
    if res[0] == -1 {
        return res
    }

    // 寻找右边界
    left, right = 0, len(nums)-1
    for left+1&lt;right {
        mid := left + (right-left)/2
        if nums[mid] &gt; target {
            right = mid
        }else {
            left = mid
        }
    }
    // 判断最后两个元素nums[left] nums[right]
    if nums[left] == target {
        res[1] = left
    }
    if nums[right] == target {
        res[1] = right
    }
    return res
}
</code></pre>
<p><a href="https://leetcode.cn/problems/binary-search/">二分查找</a></p>
<pre><code class="language-go">func search(nums []int, target int) int {
    if len(nums) == 0 {
        return -1
    }
    left, right := 0, len(nums)-1

    for left+1&lt;right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        }else if nums[mid]&gt;target {
            right = mid
        }else {
            left = mid
        }
    }
    if nums[left] == target {
        return left
    }else if nums[right] == target {
        return right
    }
    return -1
}
</code></pre>
<p><a href="https://leetcode-cn.com/problems/search-insert-position/">search-insert-position</a></p>
<pre><code class="language-go">func searchInsert(nums []int, target int) int {
    // 二分查找 左边界 第一个 &gt;= target 的位置 
    if len(nums) == 0 {
        return 0
    }
    left, right := 0, len(nums)-1

    for left+1 &lt; right {
        mid := left + (right - left)/2
        if nums[mid] &gt;= target {
            right = mid
        }else {
            left = mid
        }
    }
    if nums[left] &gt;= target {
        return left
    }else if nums[right] &gt;= target {
        return right
    }else if nums[right]&lt;target {
        return right +1
    }
    return 0
}
</code></pre>
<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">search-a-2d-matrix</a></p>
<pre><code class="language-go">func searchMatrix(matrix [][]int, target int) bool {
    // 思路 二分查找 row=mid/n col=mid%n

    m := len(matrix)
    n := len(matrix[0])

    left, right := 0, m*n-1

    for left+1&lt;right {
        mid := left + (right-left)/2
        row := mid/n
        col := mid%n
        if matrix[row][col] == target {
            return true
        }else if matrix[row][col] &gt; target {
            right = mid
        }else {
            left = mid
        }
    }

    if matrix[left/n][left%n] == target || matrix[right/n][right%n] == target {
        return true
    }
    return false
}
</code></pre>
<p><a href="https://leetcode-cn.com/problems/first-bad-version/">first-bad-version</a></p>
<pre><code class="language-go">func firstBadVersion(n int) int {
    // 二分查找 左边界
    left, right := 1, n
    for left +1 &lt; right {
        mid := left + (right-left)/2
        if isBadVersion(mid) {
            right = mid
        }else {
            left = mid
        }
    }
    if isBadVersion(left) {
        return left
    }
    if isBadVersion(right) {
        return right
    }
    return -1
}
</code></pre>
<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">find-minimum-in-rotated-sorted-array</a></p>
<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">find-minimum-in-rotated-sorted-array-ii</a></p>
<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">search-in-rotated-sorted-array</a></p>
<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">search-in-rotated-sorted-array-ii</a></p>
<pre><code class="language-go">func search(nums []int, target int) bool {
    // 二分搜索
    start, end := 0, len(nums) -1
    for start+1 &lt; end {
        // 去除重复元素
        for start &lt; end &amp;&amp; nums[start] == nums[start+1] {
            start++
        }
        for start &lt; end &amp;&amp; nums[end] == nums[end-1] {
            end--
        }
        mid := start + (end-start)/2
        if nums[mid] == target {
            return true
        }

        // 判断在左上升区间 还是右上升区间
        if nums[start] &lt; nums[mid] {
            // 左上升区间
            if nums[start] &lt;= target &amp;&amp; nums[mid] &gt;= target {
                end = mid
            }else {
                start = mid
            }
        }else if nums[end] &gt; nums[mid] {
            // 右上升区间
            if nums[end] &gt;= target &amp;&amp; nums[mid] &lt;= target {
                start = mid
            }else {
                end = mid
            }
        }
    }
    // 判断最后剩余的 start end
    if nums[start] == target || nums[end] == target {
        return true
    }
    return false
}
</code></pre>
<p><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">在排序数组中查找数字 I</a></p>
<p><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力</a></p>
<p><a href="https://leetcode.cn/problems/split-array-largest-sum/">分割数组的最大值</a></p>
<p><a href="https://leetcode.cn/problems/koko-eating-bananas/">爱吃香蕉的珂珂</a></p>
<h3 id="前缀和"><a class="header" href="#前缀和">前缀和</a></h3>
<p><a href="https://leetcode.cn/problems/range-sum-query-immutable/">区域和检索 - 数组不可变</a></p>
<pre><code class="language-go">type NumArray struct {
    data []int
    preSum []int
}

func Constructor(nums []int) NumArray {
    preSum := make([]int, len(nums)+1)
    for i := 0; i &lt; len(nums); i++ {
        preSum[i+1] = preSum[i] + nums[i]
    }
    //fmt.Println(preSum)
    return NumArray{
        data: nums,
        preSum: preSum,
    }
}

func (this *NumArray) SumRange(left int, right int) int {
    return this.preSum[right+1] - this.preSum[left]
}
</code></pre>
<p><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">二维区域和检索 - 矩阵不可变</a></p>
<pre><code class="language-go">type NumMatrix struct {
    preSum [][]int
}


func Constructor(matrix [][]int) NumMatrix {
    preSum := make([][]int, len(matrix)+1)
    preSum[0] = make([]int, len(matrix[0])+1)
    for i := 0; i&lt;len(matrix); i++ {
        if preSum[i+1] == nil {
            preSum[i+1] = make([]int, len(matrix[0])+1)
        }
        for j:=0; j&lt; len(matrix[0]); j++ {
            preSum[i+1][j+1] = preSum[i+1][j] + preSum[i][j+1] - preSum[i][j] + matrix[i][j]
        }
    }
    return NumMatrix{preSum: preSum}
}


func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {
    preSum := this.preSum
    return preSum[row2+1][col2+1] - preSum[row2+1][col1] - preSum[row1][col2+1] + preSum[row1][col1]
}
</code></pre>
<p><a href="https://leetcode.cn/problems/O4NDxx/">二维子矩阵的和</a></p>
<h3 id="差分数组"><a class="header" href="#差分数组">差分数组</a></h3>
<p><a href="https://leetcode.cn/problems/car-pooling/">拼车</a></p>
<p><a href="https://leetcode.cn/problems/corporate-flight-bookings/">航班预订统计</a></p>
<h3 id="数组遍历"><a class="header" href="#数组遍历">数组遍历</a></h3>
<p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">翻转字符串里的单词</a></p>
<pre><code class="language-go">// 多次翻转
// 首先整个字符串翻转
// 之后 每个单词再次翻转
</code></pre>
<p><a href="https://leetcode.cn/problems/rotate-image/">旋转图像</a></p>
<pre><code class="language-go">func rotate(matrix [][]int)  {
    // 1. 对角线交换，完成行列转换
    // 2. 每行翻转，完成旋转

    // 1 2 3
    // 4 5 6
    // 7 8 9

    // 1 4 7
    // 2 5 8
    // 3 6 9

    // 7 4 1
    // 8 5 2
    // 9 6 3

    for i:=0; i&lt;len(matrix); i++ {
        for j:=i; j&lt;len(matrix); j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
    for i :=0; i&lt;len(matrix); i++ {
       reverse(matrix[i])
    }
}

func reverse(nums []int) {
    i, j :=0, len(nums)-1
    for i&lt;j {
        nums[i], nums[j] = nums[j], nums[i]
        i++
        j--
    }
}
</code></pre>
<p><a href="https://leetcode.cn/problems/spiral-matrix/">螺旋矩阵</a></p>
<p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵 II</a></p>
<p><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../algorithm/tree.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../algorithm/backtrack.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../algorithm/tree.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../algorithm/backtrack.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
