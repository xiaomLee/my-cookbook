<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>动态规划</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../README.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 计算机网络</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../network/tcp&ip.html"><strong aria-hidden="true">2.1.</strong> tcp/ip</a></li><li class="chapter-item expanded "><a href="../network/http&https&tls.html"><strong aria-hidden="true">2.2.</strong> http/https</a></li><li class="chapter-item expanded "><a href="../network/http2.html"><strong aria-hidden="true">2.3.</strong> http2</a></li><li class="chapter-item expanded "><a href="../network/grpc.html"><strong aria-hidden="true">2.4.</strong> grpc</a></li><li class="chapter-item expanded "><a href="../network/udp.html"><strong aria-hidden="true">2.5.</strong> udp</a></li><li class="chapter-item expanded "><a href="../network/dns.html"><strong aria-hidden="true">2.6.</strong> dns</a></li><li class="chapter-item expanded "><a href="../network/quic.html"><strong aria-hidden="true">2.7.</strong> quic</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Linux</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../linux/README.html"><strong aria-hidden="true">3.1.</strong> linux</a></li><li class="chapter-item expanded "><a href="../linux/ids.html"><strong aria-hidden="true">3.2.</strong> 机器标识码/硬件ID</a></li><li class="chapter-item expanded "><a href="../linux/process-thread-coroutine.html"><strong aria-hidden="true">3.3.</strong> 进程/线程/协程</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 数据结构与算法</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../algorithm/list.html"><strong aria-hidden="true">4.1.</strong> List</a></li><li class="chapter-item expanded "><a href="../algorithm/stack.html"><strong aria-hidden="true">4.2.</strong> stack</a></li><li class="chapter-item expanded "><a href="../algorithm/tree.html"><strong aria-hidden="true">4.3.</strong> tree</a></li><li class="chapter-item expanded "><a href="../algorithm/array.html"><strong aria-hidden="true">4.4.</strong> array</a></li><li class="chapter-item expanded "><a href="../algorithm/backtrack.html"><strong aria-hidden="true">4.5.</strong> 回溯算法</a></li><li class="chapter-item expanded "><a href="../algorithm/dp.html" class="active"><strong aria-hidden="true">4.6.</strong> 动态规划</a></li><li class="chapter-item expanded "><a href="../algorithm/bloom.html"><strong aria-hidden="true">4.7.</strong> 布隆过滤器</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 语言</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language/golang.html"><strong aria-hidden="true">5.1.</strong> go</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 常用组件</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../components/mysql.html"><strong aria-hidden="true">6.1.</strong> mysql</a></li><li class="chapter-item expanded "><a href="../components/redis.html"><strong aria-hidden="true">6.2.</strong> redis</a></li><li class="chapter-item expanded "><a href="../components/kafka.html"><strong aria-hidden="true">6.3.</strong> kafka</a></li><li class="chapter-item expanded "><a href="../components/rabbitmq.html"><strong aria-hidden="true">6.4.</strong> rabbitmq</a></li><li class="chapter-item expanded "><a href="../components/mqtt.html"><strong aria-hidden="true">6.5.</strong> mqtt</a></li><li class="chapter-item expanded "><a href="../components/nginx.html"><strong aria-hidden="true">6.6.</strong> nginx</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 分布式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../distributed/raft.html"><strong aria-hidden="true">7.1.</strong> raft</a></li><li class="chapter-item expanded "><a href="../distributed/etcd.html"><strong aria-hidden="true">7.2.</strong> etcd</a></li><li class="chapter-item expanded "><a href="../distributed/zk.html"><strong aria-hidden="true">7.3.</strong> zookeeper</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> AI</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ai/video.html"><strong aria-hidden="true">8.1.</strong> video</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> AIOT</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> 容器技术</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../devops/docker.html"><strong aria-hidden="true">10.1.</strong> docker</a></li><li class="chapter-item expanded "><a href="../devops/k8s/README.html"><strong aria-hidden="true">10.2.</strong> kubernetes</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> 项目实践</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../projects/business-gw.html"><strong aria-hidden="true">11.1.</strong> 通用业务网关</a></li><li class="chapter-item expanded "><a href="../projects/trade-engin.html"><strong aria-hidden="true">11.2.</strong> 交易所</a></li></ol></li><li class="chapter-item expanded "><a href="../bak/bak.html"><strong aria-hidden="true">12.</strong> 归档</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/xiaomLee/my-cookbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/xiaomLee/my-cookbook/edit/master/.//algorithm/dp.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>dp.md</p>
<h1 id="动态规划"><a class="header" href="#动态规划">动态规划</a></h1>
<h2 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h2>
<p>满足两个条件</p>
<ul>
<li>满足以下条件之一
<ul>
<li>求最值</li>
<li>求是否可行</li>
<li>求可行个数</li>
</ul>
</li>
<li>满足不能排序&amp;交换</li>
</ul>
<h2 id="解题思路"><a class="header" href="#解题思路">解题思路</a></h2>
<ol>
<li><strong>状态 State</strong>
<ul>
<li>明确当前dp数组的定义，一般问题中有多少个会影响结果的变量就定义多少维的数组：dp[state1][state2][…]</li>
</ul>
</li>
<li>状态转移
<ul>
<li>写出当前状态如何由子状态递推而来，若无法推导，重新思考dp数组的定义</li>
</ul>
</li>
<li>base case
<ul>
<li>初始化最开始的极限状态</li>
</ul>
</li>
</ol>
<h2 id="常见题型"><a class="header" href="#常见题型">常见题型</a></h2>
<h3 id="矩阵类型-遍历递推"><a class="header" href="#矩阵类型-遍历递推">矩阵类型 遍历&amp;递推</a></h3>
<ol>
<li><a href="https://leetcode.cn/problems/minimum-path-sum/">64.最小路径和</a></li>
</ol>
<pre><code class="language-go">// [[1,3,1],[1,5,1],[4,2,1]]
func minPathSum(grid [][]int) int {
    // dp[i][j] 表示从(0, 0)出发到达(i, j)时的最小路径和
    // 状态转移: (i, j) 的位置只能由(i-1, j) (i, j-1)而来， 问题转换为分别到达(i-1, j) (i, j-1)的最小路径和, 注意i, j遇到边界的处理
    // dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
    // base case: dp[0][0] = grid[0][0]
    // return dp[m-1][n-1]

    // dp[i][j] 表示从 (i, j) 出发， 到达最右下角时的最小路径和
    // 要使 dp[i][j] 最小， 即 grid[i][j] + 下一步选取最小的路径即可, 下一步可选的路径是 dp[i+1][j] dp[i][j+1]
    // dp[i][j] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j] 注意边界值
    // base case dp[m-1][n-1] = grid[m-1][n-1]
    // return dp[0][0]

    m := len(grid)
    if m == 0 {
        return 0
    }
    n := len(grid[0])
    dp := make([][]int, m)
    
    for i:=m-1; i&gt;=0; i-- {
        if dp[i] == nil {
            dp[i] = make([]int, n)
        }
        for j:=n-1; j&gt;=0; j-- {
            if i == m-1 &amp;&amp; j == n-1 {
                dp[i][j] = grid[i][j]
            }else if i == m-1 {
                dp[i][j] = dp[i][j+1] + grid[i][j]
            }else if j == n-1 {
                dp[i][j] = dp[i+1][j] + grid[i][j]
            }else {
                dp[i][j] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j]
            }
        }
    }
    return dp[0][0]
}
</code></pre>
<ol start="2">
<li><a href="https://leetcode.cn/problems/triangle/">120.三角形最小路径和</a></li>
</ol>
<pre><code class="language-go">func minimumTotal(triangle [][]int) int {

    // 思路1
    // dp[i][j] 表示从(i ,j)出发， 到达最底层时的最小路径和
    // 状态转移：当前值+相邻下一层的最小值
    // dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j]
    // base case: 最后一层dp[i][j] = triangle[i][j]
    // return dp[0][0]

    dp := make([][]int, len(triangle))
    dp[len(triangle)-1] = triangle[len(triangle)-1]
    
    for i:=len(triangle)-2; i&gt;=0; i-- {
        if dp[i] == nil {
            dp[i] = make([]int, len(triangle[i]))
        }
        for j:=0; j&lt;len(dp[i]); j++ {
            if dp[i+1][j] &lt; dp[i+1][j+1] {
                dp[i][j] = dp[i+1][j] + triangle[i][j]
            }else {
                dp[i][j] = dp[i+1][j+1] + triangle[i][j]
            }
        }
    }
    return dp[0][0]



    // 思路2
    // dp[i][j] 表示从(0, 0)出发到达 (i, j)的最小路径和
    // 状态转移 当前值+上一层相邻的最小路径和
    // dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]
    // base case dp[0][0] = triangle[0][0]
    // return min(dp[len(triangle)-1])
}
</code></pre>
<ol start="3">
<li><a href="https://leetcode.cn/problems/unique-paths/">62.不同路径数</a></li>
</ol>
<pre><code class="language-go">func uniquePaths(m int, n int) int {
    // dp[i][j] 表示从(0, 0)出发 到达(i, j)共有多少种路径
    // 状态转移 (i, j)的位置只能由(i-1, j) (i, j-1)而来， 问题转换为分别到达(i-1, j) (i, j-1)的路径数量相加, 注意i, j遇到边界的处理
    // dp[i][j] = dp[i-1][j]+dp[i][j-1]
    // base case dp[0][0] = 1
    // return dp[m-1][n-1]

    dp := make([][]int, m)
    for i:=0; i&lt;m; i++ {
        if dp[i] == nil {
            dp[i] = make([]int, n)
        }
        for j:=0; j&lt;n; j++ {
            if i==0 &amp;&amp; j==0 {
                dp[i][j] = 1
            }else if i == 0 {
                dp[i][j] = dp[i][j-1]
            }else if j == 0 {
                dp[i][j] = dp[i-1][j]
            }else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            }
        }
    }
    return dp[m-1][n-1]
}
</code></pre>
<ol start="4">
<li><a href="https://leetcode.cn/problems/unique-paths-ii/">63不同路径数II</a></li>
</ol>
<pre><code class="language-go">func uniquePathsWithObstacles(obstacleGrid [][]int) int {
    // dp[i][j] 表示从(0, 0)出发 到达(i, j)共有多少种路径
    // 状态转移 (i, j)的位置只能由(i-1, j) (i, j-1)而来， 问题转换为分别到达(i-1, j) (i, j-1)的路径数量相加, 当grid[i][j]==1 时， dp[i][j]=0; 注意i, j遇到边界的处理
    // dp[i][j]= grid[i][j]==1? 0:dp[i-1][j]+dp[i][j-1]
    // base case dp[0][0] = 1 if grid[0][0] == 1 return 0
    // return dp[m-1][n-1]

}

</code></pre>
<p><strong>小结</strong></p>
<p>矩阵(三角形)类的动规问题通常需二维dp数组来存储状态。</p>
<p>dp[i][j]的定义基本为从起点出发到达(i, j)时的最大最小、总数之类的含义；
亦可定义为从(i, j)出发，到达终点时的所求值；
两种定义的差异体现在状态转移时 dp[i-1][j] dp[i][j-1]; dp[i+1][j] dp[i][j+1]</p>
<h3 id="跳跃爬楼梯"><a class="header" href="#跳跃爬楼梯">跳跃&amp;爬楼梯</a></h3>
<ol>
<li><a href="https://leetcode.cn/problems/climbing-stairs/">70.爬楼梯</a></li>
</ol>
<pre><code class="language-go">func climbStairs(n int) int {
    // dp[i] 表示到达第i阶有多少种方法
    // 状态转移 dp[i] = dp[i-1] + dp[i-2]
    // base case 第0阶表示地面 dp[0] = 1 dp[1] = 1
    // return dp[n]
}
</code></pre>
<ol start="2">
<li><a href="https://leetcode.cn/problems/jump-game/">55.跳跃游戏</a></li>
</ol>
<pre><code class="language-go">func canJump(nums []int) bool {

    // 思路1
    // dp[i] 表示从0出发 能否到达第i个下标
    // 状态转移 dp[i] 依赖于所有 &lt;i 的点当中是否有可以到达i的下标，即 dp[j] &amp;&amp; nums[j]&gt;=i-j 
    // base case dp[0]=true
    // return dp[len(nums)-1]
	dp := make([]bool, len(nums))
	for i:=0; i&lt;len(nums); i++ {
		if i == 0 {
			dp[0] = true
			continue
		}
		for j:=0; j &lt; i; j++ {
			if dp[j] &amp;&amp; i-j &lt;= nums[j] {
				dp[i] = true
				break
			}
		}
	}
	return dp[len(nums)-1]

    // 思路2
    // dp[i] 表示从出发， 能否到达终点
    // 状态转移 dp[i] 依赖于下标i所能到达的下一批点位中是否有能到达终点的下标， 即  for j&lt;=nums[i]{ dp[i] = dp[i] || dp[i+j] }
    // base case dp[len(nums)-1] = true
    // return dp[0]
}
</code></pre>
<ol start="3">
<li><a href="https://leetcode.cn/problems/jump-game-ii/">45.跳跃游戏II</a></li>
</ol>
<pre><code class="language-go">func jump(nums []int) int {
    // dp[i] 表示从nums[i] 到最后一个位置的最少次数
    // 状态转移 dp[i] = min(dp[i+0], dp[i+1], ..., dp[i+nums[i]]) + 1
    // base case dp[n-1] = 0


    // dp[i] 表示到达 i 的最小跳跃次数
	// dp[i] = min(dp[:i-1] &amp;&amp; nums[j] &gt;= i-j) + 1
	// base case dp[0] = 0

	dp := make([]int, len(nums))
	for i:=0; i&lt;len(nums); i++ {
		if i == 0 {
			dp[0] = 0
			continue
		}
		dp[i] = math.MaxInt32
		for j:=0; j&lt;i; j++ {
			if nums[j] &gt;= i-j &amp;&amp; dp[i] &gt; dp[j] {
				dp[i] = dp[j] + 1
			}
		}
	}
	return dp[len(nums)-1]
}
</code></pre>
<p><strong>小结</strong></p>
<p>跳跃爬楼梯问题通常用一维dp表来存储状态。</p>
<p>定义基本为：从初始点到达当前点 或 从当前点到达终点</p>
<p>状态推导思路：从之前几个状态进行推导 mix max</p>
<h3 id="子序列子串问题"><a class="header" href="#子序列子串问题">子序列&amp;子串问题</a></h3>
<ol>
<li><a href="https://leetcode.cn/problems/maximum-subarray/">53.最大子数组和</a></li>
</ol>
<pre><code class="language-go">func maxSubArray(nums []int) int {
    // dp[i] 表示以nums[i]为结尾的连续子数组，最大数组和
    // 状态转移 如果dp[i-1]&gt;0 dp[i]=dp[i-1]+nums[i] 否则 dp[i] = nums[i]
    // base case dp[0]=nums[0]
    // return max(dp[:])
    
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    max := dp[0]
    for i:=1; i&lt;len(nums); i++ {
        dp[i] = nums[i]
        if dp[i-1] &gt; 0 {
            dp[i] = dp[i-1] + nums[i]
        }
        if dp[i]&gt;max {
            max = dp[i]
        }
    }
    return max
}
</code></pre>
<ol start="2">
<li><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a></li>
</ol>
<pre><code class="language-go">func lengthOfLIS(nums []int) int {
    // dp[i] 表示以 nums[i] 为递增子序列的结尾，其所有子序列中的最大长度
    // 状态转移 遍历nums[:i] if nums[j]&lt;nums[i] dp[i] = max(dp[i], dp[j]+1)
    // base case dp[0] = 1
    // return max(dp[:])
    dp := make([]int, len(nums))
	res := 0
	for i:=0; i&lt;len(nums); i++ {
		if i == 0 {
			dp[i] = 1
			res = dp[i]
			continue
		}
		dp[i] = 1
		for j:=0; j&lt;i; j++ {
			if nums[i] &gt; nums[j] &amp;&amp; dp[i] &lt; dp[j] +1 {
				dp[i] = 1 + dp[j]
			}
		}
		if dp[i] &gt; res {
			res = dp[i]
		}
	}
	return res
}
</code></pre>
<ol start="3">
<li><a href="https://leetcode.cn/problems/palindrome-partitioning/">131.分割回文串</a> 回溯算法</li>
</ol>
<pre><code class="language-go">func partition(s string) [][]string {
	var backtrack func(s string, pos int, track []string, res *[][]string) 
	backtrack = func(s string, pos int, track []string, res *[][]string) {
		if pos == len(s) {
			ans := make([]string, len(track))
			copy(ans, track)
			*res = append(*res, ans)
			return
		}
		for i:=pos; i&lt;len(s); i++ {
			// 对于每一个 s[i] 都有两种选择：分割 or 不分割
			if !isPalindrome(s[pos:i+1]) {
				continue
			}
			track = append(track, s[pos:i+1])
			backtrack(s, i+1, track, res)
			track = track[:len(track)-1]
		}
	}

	track := make([]string, 0)
	res := make([][]string, 0)
	backtrack(s, 0, track, &amp;res)
	return res
}

func isPalindrome(s string) bool {
	if len(s) &lt;= 1 {
		return true
	}
	i, j:= 0, len(s)-1
	for i&lt;j {
		if s[i] != s[j] {
			return false
		}
		i++
		j--
	}
	return true
}

</code></pre>
<ol start="4">
<li><a href="https://leetcode.cn/problems/palindrome-partitioning-ii/">132.分割回文串II</a> 求最小分割次数</li>
</ol>
<pre><code class="language-go">func minCut(s string) int {
	// dp[i] 表示将 s[:i] 分割成都是回文子串的最小分割次数 0&lt;= i &lt;= len(s)
	// 则 dp[i] = min(dp[j] &amp;&amp; s[j:i] isPalindrome) + 1
	// base case dp[0] = 0 dp[1] = 0 dp[i] = i-1
	// return dp[len(s)]

	isPalindrome := func(s string) bool {
		for i,j:=0, len(s)-1; i&lt;j; i, j= i+1, j-1{
			if s[i] != s[j] {
				return false
			}
		}
		return true
	}

	huiwen := make([][]bool, len(s)+1)
	for i:=0; i&lt;len(s); i++ {
		if huiwen[i] == nil {
			huiwen[i] = make([]bool, len(s)+1)
		}
		for j:=i; j&lt;=len(s); j++ {
			huiwen[i][j] = isPalindrome(s[i:j])
		}
	}

	dp := make([]int, len(s)+1)
	for i:=0; i&lt;=len(s); i++ {
		if i &lt;= 1 || huiwen[0][i] {
			dp[i] = 0
			continue
		}

		dp[i] = i - 1
		for j:=0; j&lt;i; j++ {
			if huiwen[j][i] &amp;&amp; dp[j] + 1 &lt; dp[i] {
				dp[i] = dp[j] + 1
			}
		}
	}
	return dp[len(s)]
}
</code></pre>
<ol start="5">
<li><a href="https://leetcode.cn/problems/longest-valid-parentheses/description/">32.最长有效括号</a></li>
</ol>
<pre><code class="language-go">// dp[i] 表示以 s[i] 为结尾的最长有效括号长度
	// 则 
	// 1. 若 s[i] == '(' 以 s[i] 为结尾的最长有效括号为必定为 0 ： dp[i] = 0
	// 2. 若 s[i] == ')' 需根据 s[i-1] 做状态转移
	// 2.1 若 s[i-1] == '(' 则 s[i-1] s[i] 已能组成有效括号 dp[i] = dp[i-2] + 2
	// 2.2 若 s[i-1] == ')' 则 需判断 dp[i-1] 
	// 2.2.1 若 dp[i-1] == 0 则 dp[i] =0 
	// 2.2.2 若 dp[i-1] &gt; 0 &amp;&amp; i - dp[i-1]&gt;0 &amp;&amp; s[i - dp[i-1] -1 ] == '(' 则 dp[i] = dp[i-1] + 2 + dp[i- dp[i-1] -2]
	// (subs) ( (sub_s) ) 
	// base case: dp[0] = 0
	// return max(dp[:])

	dp := make([]int, len(s))
	res := 0
	for i :=0; i&lt;len(s); i++ {
		if i == 0 {
			dp[i] = 0
			continue
		}
		if i == 1 {
			if s[i] == ')' &amp;&amp; s[i-1] == '(' {
				dp[i] = 2
				res = dp[i]
			}else {
				dp[i] = 0
			}
			continue
		}
		
		if s[i] == ')' &amp;&amp; s[i-1] == '(' {
			dp[i] = dp[i-2] + 2
		}else if s[i] == ')' &amp;&amp; s[i-1] == ')' &amp;&amp;
		 dp[i-1] &gt; 0 &amp;&amp; i - dp[i-1] -1 &gt;= 0 &amp;&amp; s[i - dp[i-1] -1 ] == '(' {
			dp[i] = dp[i-1] + 2
			if i-dp[i-1]-2&gt;= 0 {
				dp[i] = dp[i] + dp[i- dp[i-1] -2]
			}
		}

		if dp[i] &gt; res {
			res = dp[i]
		}
	}
	return res
</code></pre>
<ol start="6">
<li><a href="https://leetcode.cn/problems/word-break/">139.单词拆分</a></li>
</ol>
<pre><code class="language-go">func wordBreak(s string, wordDict []string) bool {
    // dp[i] 表示s[:i]能否由wordDict拼接出
    // 状态转移 遍历s[:i] dp[i] = (s[:i] in wordDict) || (dp[j] &amp;&amp; s[j:i] in wordDict)
    // base case dp[0] = true
    // return dp[len(s)]
    dict := make(map[string]bool)
	for _, word := range wordDict {
		dict[word] = true
	}

	dp := make([]bool, len(s)+1)
	for i:=0; i&lt;=len(s); i++ {
		if i == 0 {
			dp[0] = true
			continue
		}
		for j:=0; j&lt;i; j++ {
			if dp[j] &amp;&amp; dict[s[j:i]] {
				dp[i] = true
				break
			}
		}
	}
	return dp[len(s)]
}
</code></pre>
<p><strong>小结</strong>
动规子序列/子串问题通常用一维dp表来存储状态。问题7，最长回文子串不适于本分类，需要用二维数组来表示状态，此处仅做为记录。</p>
<p>定义基本为：一维数组dp[i], 表示将当前点作为结尾的结果，然后对s[i] 或者s[:i]做复合题意的判断</p>
<h3 id="两序列比对问题"><a class="header" href="#两序列比对问题">两序列比对问题</a></h3>
<ol>
<li><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143.最长公共子序列</a></li>
</ol>
<pre><code class="language-go">func longestCommonSubsequence(text1 string, text2 string) int {
    // dp[i][j] 表示text1[:i] text2[:j] 的最长公共子序列长度
    // 状态转移 
    // text1[i] == text2[j] dp[i][j] = dp[i-1][j-1] + 1
    // text1[i] != text2[j] dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    // base case dp[0][0] = 0 dp[i][0] = 0 dp[0][j] = 0
    // return dp[len(text1)][len(text2)]
    dp := make([][]int, len(text1)+1)
	for i:=0; i&lt;=len(text1); i++ {
		if dp[i] == nil {
			dp[i] = make([]int, len(text2)+1)
		}
		for j:=0; j&lt;=len(text2); j++ {
			if i==0 || j == 0 {
				dp[i][j] = 0
				continue
			}
			if text1[i-1] == text2[j-1] {
				dp[i][j] = dp[i-1][j-1] + 1
			}else if  dp[i-1][j] &gt; dp[i][j-1] {
				dp[i][j] = dp[i-1][j]
			}else {
				dp[i][j] = dp[i][j-1]
			}
		}
	}
	return dp[len(text1)][len(text2)]
}

</code></pre>
<ol start="2">
<li><a href="https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=295&amp;tqId=991150&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj">最长公共子串</a></li>
</ol>
<pre><code class="language-go">func longestCommonSubstring(str1 string, str2 string) string {
    // dp[i][j] 表示以 str1[i] str2[j]结尾的最长公共子串
    // 状态转移 
    // str1[i] == str2[j] dp[i][j] = dp[i-1][j-1] + str1[i:i+1]
    // str1[i] != str2[j] dp[i][j] = ""
    // base case  dp[i][0] = "" dp[0][j] = "" dp[0][0] = str1[0]==str2[0]?str1[0:1]:""
    // return max(dp[i][j])
}
</code></pre>
<ol start="3">
<li><a href="https://leetcode.cn/problems/edit-distance/">72.编辑距离</a></li>
</ol>
<pre><code class="language-go">func minDistance(word1 string, word2 string) int {
    
    // 思路1
    // dp[i][j] 表示将 word1[:i] 变成 word2[:j] 所需的最少操作
    // 状态转移 
    // 1. word1[i-1] == word2[j-1] 无需操作 dp[i][j] = dp[i-1][j-1]
    // 2. word1[i-1] != word2[j-1] 插入、删除、替换 取最小 dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1
    // base case dp[0][0] = 0  dp[i][0] = i dp[0][j] = j 
    // return dp[len(word1)][len(word2)]

    // 思路2
    // max(len(str1), len(str2)) - LCS
    // LCS算法参考最长公共子序列

    dp := make([][]int, len(str1)+1)
    for i:=0; i&lt;=len(str1); i++ {
        //fmt.Println(i)
        if dp[i] == nil {
            dp[i] = make([]int, len(str2)+1)
        }
        for j:=0; j&lt;=len(str2); j++ {
            if i== 0 {
                dp[i][j] = j
                continue
            }else if j == 0 {
                dp[i][j] = i
                continue
            }
            if str1[i-1] == str2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            }else {
                dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1
            }
        }
    }
    return dp[len(str1)][len(str2)]
}
</code></pre>
<ol start="4">
<li><a href="https://leetcode.cn/problems/regular-expression-matching/">10.正则表达式</a></li>
</ol>
<pre><code class="language-go">    // dp[i][j] 表示 s[:i] p[:j] 能否匹配
    // 则存在如下状态转换
    // p[j-1] == s[i-1] 匹配掉当前字符 dp[i][j] = dp[i-1][j-1]
    // p[j-1] == '.' 仅能匹配一个任意字符 dp[i][j] = dp[i-1][j-1]
    // p[j-1] == '*' 匹配0个p[j-2]字符 dp[i][j] = dp[i][j-2] || dp[i-1][j-2] || dp[i-1][j]
    // p[j-1] != '.' &amp;&amp; p[j-1] != '*' dp[i][j] = false
    // base case dp[i][0] = i==0 dp[0][j] = j &gt;= 2 &amp;&amp; j%2 == 0 &amp;&amp; p[j-1] == '*' false : dp[i][j-2]
				

    dp := make([][]bool, len(s)+1)
    for i:=0; i&lt;=len(s); i++ {
        if dp[i] == nil {
            dp[i] == make([]bool, len(p)+1)
        }
        for j:=0; j&lt;=len(p); j++ {
            if j == 0 {
                dp[i][j] = i==0
                continue
            }
            if i == 0 {
                dp[i][j] = false
				if j &gt;= 2 &amp;&amp; j%2 == 0 &amp;&amp; p[j-1] == '*' {
					dp[i][j] = dp[i][j-2]
				}
				continue
            }
            if p[j-1] == s[i-1] {
                dp[i][j] = dp[i-1][j-1]
            }else if p[j-1] == '.' {
                dp[i][j] = dp[i-1][j-1]
            }else if p[j-1] == '*' {
                dp[i][j] = dp[i][j-2] 
                if p[j-2] == s[i-1] || p[j-2] == '.' {
                    dp[i][j] = dp[i][j-2] || dp[i-1][j-2] || dp[i-1][j]
                }
            }else {
                dp[i][j] = false
            }
        }
    }
    return dp[len(s)][len(p)]

</code></pre>
<ol start="5">
<li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28.strstr / KMP算法</a></li>
</ol>
<pre><code class="language-go">
</code></pre>
<p><strong>小结</strong>
两个序列的动规问题，需定义一个二维dp表， 所代表的意义一般是 str1[:i] str2[:j] 的最值
状态转移一般 dp[i][j] = min/max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) 此类型的方程
需注意dp的长度通常会Len(str1)+1</p>
<h3 id="区间dp"><a class="header" href="#区间dp">区间dp</a></h3>
<ol>
<li><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5.最长回文子串</a></li>
</ol>
<pre><code class="language-go">func longestPalindrome(s string) string {

    // 思路1 动规
    // dp[i][j] 表示 s[i:j]是否是回文串
    // 状态转移 dp[i][j] 依赖于 s[i] == s[j] &amp;&amp; dp[i+1][j-1]
    // base case dp[0][0] = true dp[i][i] = true
    // return range dp &amp;&amp; max(i-j)


    // 思路2 中心扩散法
    // 回文串存在奇数偶数之分， 分别以i,  (i, i+1)为中心寻找最长回文子串
    // max(res, max(res1, res2))
}

// 扩散寻找最长回文串
func findPalindrome(s string, i, j int) string{
    for i&gt;=0 &amp;&amp; j&lt;len(s) {
        if s[i] != s[j] {
            break
        }
        i--
        j++
    }
    return s[i+1:j]
}
</code></pre>
<ol start="2">
<li><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516.最长回文子序列</a></li>
</ol>
<pre><code class="language-go">func longestPalindromeSubseq(s string) int {
	// dp[i][j] 表示 s[j:i] 的最长回文子序列
	// 1. s[i] == s[j] dp[i][j] = max(dp[i-1][j+1]+2, dp[i-1][j], dp[i][j+1])
	// 2. s[i] != s[j] dp[i][j] = max(dp[i-1][j+1], dp[i-1][j], dp[i][j+1])
	// base case: dp[0][0] = 1 
	// return dp[0][len(s)-1]
	
	max := func(ints ...int) int {
		sort.Ints(ints)
		return ints[len(ints)-1]
	}

	dp := make([][]int, len(s))
	for i:=0; i&lt;len(s); i++ {
		if dp[i] == nil {
			dp[i] = make([]int, len(s))
		}
		for j:=i; j&gt;=0; j-- {
			if i==0 || j==i {
				dp[i][j] = 1
				continue
			}
			if s[j] == s[i] {
				dp[i][j] = max(dp[i-1][j+1]+2, dp[i-1][j], dp[i][j+1])
			}else {
				dp[i][j] = max(dp[i-1][j+1], dp[i-1][j], dp[i][j+1])
			}
		}
	}
	return dp[len(s)-1][0]
}
</code></pre>
<ol start="3">
<li><a href="https://leetcode.cn/problems/scramble-string/description/">87.扰乱字符串</a></li>
</ol>
<pre><code class="language-go">func isScramble(s1 string, s2 string) bool {
	// 递归 + 记忆搜索
	// tips:
	// 1. 可对 s1 s2 进行 hascode 进行初步判断筛选(长度、字母异位词)
	// 2. 对每次结果进行存储，防止重复计算
	memo := make(map[string]bool)
	var recursive func(s1, s2 string, memo map[string]bool) bool
	var hashCode func(s string) int 
	recursive = func (s1, s2 string, memo map[string]bool) bool {
		if len(s1) != len(s2) {
			return false
		}
		if hashCode(s1) != hashCode(s2) {
			return false
		}
		if s1==s2 {
			return true
		}
		if ans, ok := memo[s1+s2]; ok {
			return ans
		}
	
		n := len(s1)
		for i:=0; i&lt;n-1; i++ {
			if recursive(s1[:i+1], s2[:i+1], memo) &amp;&amp; recursive(s1[i+1:], s2[i+1:], memo) {
				memo[s1+s2] = true
				memo[s2+s1] = true
				return true
			}
			
			if recursive(s1[:i+1], s2[n-i-1:], memo) &amp;&amp; recursive(s1[i+1:], s2[:n-i-1], memo) {
				memo[s1+s2] = true
				memo[s2+s1] = true
				return true
			}
		}
		memo[s1+s2] = false
		memo[s2+s1] = false
		return false
	}
	
	hashCode = func(s string) int {
		var code int
		for _, char := range s {
			code += 1&lt;&lt;(char - 'a')
		}
		return code
	}
	

	return recursive(s1, s2, memo)
}

</code></pre>
<ol start="4">
<li><a href="https://leetcode.cn/problems/burst-balloons/description/">312.戳气球</a></li>
<li>[能量向量]</li>
<li>[石子合并]</li>
<li>[248G]</li>
<li>[涂色]</li>
<li><a href="https://leetcode.cn/problems/palindrome-removal/description/">1246.删除回文子数组</a></li>
</ol>
<p><strong>小结</strong>
区间DP整体框架模型上有点类似回文串的中心扩散法（或递归子问题），先求解中间某段的结果，然后向两端扩散求解。</p>
<ul>
<li>比如 <a href="https://leetcode.cn/problems/longest-palindromic-substring/">5.最长回文子串</a> <a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516.最长回文子序列</a> 都是先求解 s[i:j] 是不是回文串(或最大长度)，之后通过 s[i-1] == s[j+1] 进行扩散</li>
<li></li>
</ul>
<h3 id="零钱兑换"><a class="header" href="#零钱兑换">零钱兑换</a></h3>
<ol>
<li><a href="https://leetcode.cn/problems/coin-change/">322.零钱兑换</a></li>
</ol>
<pre><code class="language-go">func coinChange(coins []int, amount int) int {
    // dp[i] 表示凑出 i金额最少的硬币数
    // 状态转移 针对金额i 循环coins  dp[i] = min(dp[i], dp[i-coins[j]]+1)
    // base case dp[0] = 0 dp[i] = amount+1
    // return dp[amount]==amount+1 ? -1:dp[amount]
}
</code></pre>
<ol start="2">
<li><a href="https://leetcode.cn/problems/coin-change-2/">518.零钱兑换II</a></li>
</ol>
<pre><code class="language-go">func change(amount int, coins []int) int {
    // dp[i] 表示 凑出 i 金额的组合数
    // 状态转移 为凑出i金额 可先凑出 ’i - 某一种面额的硬币’ 的金额；类比爬楼梯，要到达i  先到达 i-step
    // 循环coins dp[i] += dp[i-coins[j]]
    // base case dp[0] = 1
    // return dp[amount]
}
</code></pre>
<p><strong>小结</strong></p>
<ul>
<li>零钱兑换问题需定义一维dp数组dp[i]，表示凑出i金额时的所求解</li>
<li>状态转移：为凑出i金额 可先凑出 ’i - 某一种面额的硬币’ 的金额，dp[i] = min(dp[i], dp[i-coins[j]]+1)</li>
<li>base case dp[0] = 0 dp[i] = amount+1</li>
<li>return dp[amount]</li>
</ul>
<h3 id="背包问题"><a class="header" href="#背包问题">背包问题</a></h3>
<ol>
<li><a href="https://www.lintcode.com/problem/92/">背包问题</a></li>
</ol>
<pre><code class="language-go">func BackPack(m int, a []int) int {
    // write your code here
    // dp[i][w] 表示针对前 i 个物品 容量为 w 时， 最多能装多满
    // 对于每一个物品， 有装入 不装入两种选择
    // 状态转移 dp[i][w] = max(dp[i-1][w], dp[i-1][w-a[i-1]] + a[i-1])
    // base case dp[0][:] = 0 dp[:][0] = 0
    // return dp[len(a)][m]

    dp := make([][]int, len(a)+1)
    dp[0] = make([]int, m+1)
    for i:=1; i&lt;=len(a); i++ {
        if dp[i] == nil {
            dp[i] = make([]int, m+1)
        }
        for j:=0; j&lt;=m; j++ {
            if j == 0 {
                dp[i][j] = 0
                continue
            }
            // dp[i][w] = max(dp[i-1][w], dp[i-1][w-a[i-1]] + a[i-1])
            dp[i][j] = dp[i-1][j]
            if j-a[i-1] &gt;=0 {
                dp[i][j] = max(dp[i][j], dp[i-1][j-a[i-1]] + a[i-1])
            }
        }
    }
    return dp[len(a)][m]
}

func max(a, b int) int {
    if a&gt;b {
        return a
    }
    return b
}
</code></pre>
<ol start="2">
<li><a href="https://www.lintcode.com/problem/125/">背包问题II</a></li>
</ol>
<pre><code>
</code></pre>
<ol start="3">
<li>[分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum</li>
</ol>
<pre><code class="language-go">func canPartition(nums []int) bool {
    // 转换成背包问题 target = sum/2
    // 背包容量为 target 从 nums 中选取元素， 求能否恰好装满
    sum := 0
    for i:=0; i&lt;len(nums); i++ {
        sum += nums[i]
    }
    if sum%2 != 0 {
        // 无法均分
        return false 
    }
    target := sum/2

    // dp[i][w] 表示针对第 i 个物品， 还有 w 容量时，能否装满
    // 状态转移 dp[i][w] = dp[i-1][w] || dp[i-1][w-nums[i]]
    // base case dp[0][:] = false dp[:][0] = true
    dp := make([][]bool, len(nums)+1)
    dp[0] = make([]bool, target+1)

    for i:=1; i&lt;=len(nums); i++ {
        if dp[i] == nil {
            dp[i] = make([]bool, target+1)
        }
        for j:=0; j&lt;=target; j++ {
            if j == 0 {
                dp[i][j] = true
                continue
            }
            dp[i][j] = dp[i-1][j]
            if j-nums[i-1] &gt;= 0 {
                dp[i][j] = dp[i][j] || dp[i-1][j-nums[i-1]]
            }
        }
    }
    return dp[len(nums)][target]
}
</code></pre>
<p><strong>小结</strong></p>
<ul>
<li>背包问题需定义二维数组dp[i][w], 表示对于前i个物品，且前背包容量为w时 所求问题的结果——一般是最值</li>
<li>状态转移：对于第i个物品，有两种选择——装入、不装入，对应的状态分别是dp[i-1][w]  value[i] + dp[i-1][w-wt[i]]</li>
<li>base case dp[0][…] = dp[…][0] = 0</li>
<li>return dp[n][w]</li>
</ul>
<h3 id="股票问题"><a class="header" href="#股票问题">股票问题</a></h3>
<ol>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">股票买卖的最佳时机</a></li>
</ol>
<pre><code class="language-go">func maxProfit(prices []int) int {
    // dp[i][j] 表示第天i天 分别在持仓、未持仓状态下的收益 j = {0, 1}
    // 状态转移 
    // 第i天未持仓: 前一天也未持仓、或前一天持仓当天卖出 dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
    // 第i天持仓： 前一天也持仓、或前一天未持仓今天买入 dp[i][1] = max(dp[i-1][1], 0-prices[i])  ps: 因为只买卖一次， 所以此处是0-prices[i]
    // base case dp[0][0] = 0 dp[0][1] = -prices[0]
    // return dp[len(prices)-1][0]

    dp:=make([][]int, len(prices))
    dp[0] = make([]int, 2)
    dp[0][0] = 0
    dp[0][1] = -prices[0]

    var max func(a, b int) int
    max = func(a, b int) int {
        if a&gt;b {
            return a
        }
        return b
    }

    for i:=1; i&lt;len(prices); i++ {
        dp[i] = make([]int, 2)
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp[i][1] = max(dp[i-1][1], 0-prices[i])
    }
    return dp[len(prices)-1][0]


    // 思路2
    // 因为只进行一次买卖， 只需找到相差最大的波峰与波谷即可
    // 用一个变量记录 prices[:i]之前的最小价格 minPrice, profit = prices[i] - minPrice
    // 循环prices， return max(profit)
}
</code></pre>
<ol start="2">
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">股票买卖的最佳时机2</a></li>
</ol>
<pre><code class="language-go">func maxProfit(prices []int) int {
    // dp[i][j] 表示第天i天 分别在持仓、未持仓状态下的收益 j = {0, 1}
    // 状态转移 
    // 第i天未持仓: 前一天也未持仓、或前一天持仓当天卖出 dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
    // 第i天持仓： 前一天也持仓、或前一天未持仓今天买入 dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]) 
    // base case dp[0][0] = 0 dp[0][1] = -prices[0]
    // return dp[len(prices)-1][0]

    dp:=make([][]int, len(prices))
    dp[0] = make([]int, 2)
    dp[0][0] = 0
    dp[0][1] = -prices[0]

    var max func(a, b int) int
    max = func(a, b int) int {
        if a&gt;b {
            return a
        }
        return b
    }

    for i:=1; i&lt;len(prices); i++ {
        dp[i] = make([]int, 2)
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
    }
    return dp[len(prices)-1][0]


    // 贪心算法
    // 因为不限买卖次数， 即每一天的价格差都可获利
    // if prices[i+1] &gt; prices[i] { profit += prices[i+1] - prices[i] }
    // return profit
}
</code></pre>
<ol start="3">
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">股票买卖的最佳时机3</a> 交易次数限制 2次</li>
</ol>
<pre><code class="language-go">func maxProfit(prices []int) int {
    // dp[i][k][j] 表示第i天 最大k次交易限制 持仓/未持仓时的收益; K只在买入的时候-1, 初始值为最大买入次数
    // 状态转移
    // 1. 第i天 最大k次交易 未持仓：前一天也未持仓今天不操作(dp[i-1][k][0]), 或 前一天持仓今天卖出(dp[i-1][k][1]+price[i]) 
    // 2. 第i天 最大k次交易 持仓：前一天未持仓今天买入(dp[i-1][k-1][0]-prices[i]), 或  前一天持仓今天不操作(dp[i-1][k][1])
    // base case dp[0][k][0] = 0 dp[0][k][1] = -prices[0] dp[i][0][0] = 0 dp[i][0][1] = math.MinInt32
    // return dp[len(preices)-1][max_k][0]

    dp := make([][][]int, len(prices))
    K := 2
    var max func(a, b int) int
    max = func(a, b int) int {
        if a&gt;b {
            return a
        }
        return b
    }

    for i:=0; i&lt;len(preices); i++ {
        if dp[i] == nil {
            dp[i] = make([][]int, K+1)
        }
        for k:=K; k&gt;=0; k-- {
            if dp[i][k] == nil {
                dp[i][k] = make([]int, 2)
            }
            if i==0 {
                dp[i][k][0] = 0
                dp[i][k][1] = -prices[i]
                continue
            }
            if k == 0 {
                dp[i][0][0] = 0
                dp[i][0][1] = math.MinInt32
            }
            dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+prices[i])
            dp[i][k][1] = max(dp[i-1][k-1][0]-prices[i], dp[i-1][k][1])
        }
    }

    return dp[len(prices)-1][K][0]
}
</code></pre>
<ol start="4">
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">股票买卖的最佳时机4</a> 交易次数限制 k次</li>
</ol>
<pre><code class="language-go">func maxProfit(K int, prices []int) int {
    // 同上 3
}
</code></pre>
<ol start="5">
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">股票买卖的最佳时机5</a> 交易冷冻期</li>
</ol>
<pre><code class="language-go">func maxProfit(prices []int) int {
    cooldown := 2
    // dp[i][j] 表示在第i天分别持仓 不持仓状态下的最大收益
    // 状态转移 
    // dp[i][0] 第i天不持仓: i-1天也不持仓 或 i-1天持仓今天卖出； max(dp[i-1][0], dp[i-1][1]+prices[i])
    // dp[i][1] 第i天持仓：今天买入且冷冻期前不持仓 或 i-1天持仓； max(dp[i-cooldown][0]-prices[i], dp[i-1][1]) 
    // base case dp[0][0] = 0 dp[0][1] = -prices[0]
    // return dp[len(prices)-1][0]

    dp:=make([][]int, len(prices))
    var max func(a, b int) int
    max = func(a, b int) int {
        if a&gt;b {
            return a
        }
        return b
    }

    for i:=0; i&lt;len(prices); i++ {
        if dp[i] == nil {
            dp[i] = make([]int, 2)
        }
        if i == 0 {
            dp[i][0] = 0
            dp[i][1] = -prices[i]
            continue
        }
        if i-cooldown &lt; 0 {
            // base case 2
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
            // i - 2 小于 0 时根据状态转移方程推出对应 base case
            dp[i][1] = max(dp[i-1][1], -prices[i]);
            continue
        }
        dp[i][0] =  max(dp[i-1][0], dp[i-1][1]+prices[i])
        dp[i][1] = max(dp[i-cooldown][0]-prices[i], dp[i-1][1])
    }
    return dp[len(prices)-1][0]
}
</code></pre>
<ol start="6">
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">股票买卖的最佳时机6</a> 手续费</li>
</ol>
<pre><code class="language-go">func maxProfit(prices []int, fee int) int {
    // 不限交易次数， 同2， 注意收益值减去fee
}
</code></pre>
<p><strong>小结</strong></p>
<p>股票类问题定义一个二维 或三维的dp数组(适用于有交易次数限制的题)， 例如 dp[i][j] i表示天数 j取值0,1分别代表是否持仓；
然后根据当天的持仓状态写出状态转移方程
基本形如</p>
<ul>
<li>dp[i][0] 第i天不持仓: i-1天也不持仓 或 i-1天持仓今天卖出； max(dp[i-1][0], dp[i-1][1]+prices[i])</li>
<li>dp[i][1] 第i天持仓：今天买入且前一天不持仓 或 i-1天持仓； max(dp[i-1][0]-prices[i], dp[i-1][1])</li>
</ul>
<p>针对只限一次交易 或不限交易次数的题， 亦有其他取巧方法， 比如不限交易可用贪心算法(每天的价格差累计即可)</p>
<p>对于含冷冻期 或手续费的题状态转移方程稍作变更即可</p>
<p>若限制交易次数 则需定义三维数组 dp[i][k][j] 表示在第i天 在最大交易次数k的限制下 分别持仓不持仓的收益</p>
<p>状态转移</p>
<ol>
<li>第i天 最大k次交易 未持仓：前一天也未持仓今天不操作(dp[i-1][k][0]), 或 前一天持仓今天卖出(dp[i-1][k][1]+price[i])</li>
<li>第i天 最大k次交易 持仓：前一天未持仓今天买入(dp[i-1][k-1][0]-prices[i]), 或  前一天持仓今天不操作(dp[i-1][k][1])</li>
<li>base case dp[0][k][0] = 0 dp[0][k][1] = -prices[0] dp[i][0][0] = 0 dp[i][0][1] = math.MinInt32</li>
</ol>
<h3 id="打家劫舍"><a class="header" href="#打家劫舍">打家劫舍</a></h3>
<ol>
<li><a href="https://leetcode.cn/problems/house-robber/">打家劫舍1</a> 数组链表</li>
<li><a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍2</a> 环形链表</li>
<li><a href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍3</a> 树形结构</li>
</ol>
<p><strong>小结</strong></p>
<ul>
<li>定义一维数组dp[i] 表示到第 i 家房屋，所能偷的最大金额</li>
<li>状态转移：对当前房屋i有两种选择——偷、不偷，最大收益分别对应 dp[i-2] + nums[i], dp[i-1]; max(偷， 不偷)</li>
<li>base case dp[0] = 0 dp[1] = nums[0]</li>
<li>对于环形链表，分两种base case：偷第一家不偷最后一家(dp[1]=nums[0]), 不偷第一家(dp[1]=0)</li>
</ul>
<h3 id="刷题列表"><a class="header" href="#刷题列表">刷题列表</a></h3>
<p><a href="https://books.halfrost.com/leetcode/ChapterTwo/Dynamic_Programming/">参考</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../algorithm/backtrack.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../algorithm/bloom.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../algorithm/backtrack.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../algorithm/bloom.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
